diff --git a/include/libnfs-private.h b/include/libnfs-private.h
index e741dfe..0cf5183 100644
--- a/include/libnfs-private.h
+++ b/include/libnfs-private.h
@@ -776,6 +776,9 @@ struct nfs_cb_data {
        void (*free_continue_data)(void *);
        uint64_t continue_int;
 
+       /* For opendir_at_cookie: max entries to fetch (0 = unlimited) */
+       uint32_t max_entries;
+
        struct nfs_fh fh;
 
        /* for multi-read/write calls. */
@@ -812,6 +815,11 @@ struct nfsdir {
 
        struct nfsdirent *entries;
        struct nfsdirent *current;
+
+       /* Cookie verifier from last READDIR/READDIRPLUS response.
+        * Applications need this to resume streaming with
+        * nfs_opendir_names_only_at_cookie(). */
+       uint64_t cookieverf;
 };
 
 struct stateid {
@@ -899,6 +907,17 @@ int nfs3_open_async(struct nfs_context *nfs, const char *path, int flags,
                     int mode, nfs_cb cb, void *private_data);
 int nfs3_opendir_async(struct nfs_context *nfs, const char *path, nfs_cb cb,
                        void *private_data);
+int nfs3_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                                 uint64_t cookie, uint32_t max_entries,
+                                 nfs_cb cb, void *private_data);
+int nfs3_opendir_names_only_async(struct nfs_context *nfs, const char *path,
+                                  nfs_cb cb, void *private_data);
+int nfs3_opendir_names_only_at_cookie_async(struct nfs_context *nfs,
+                                             const char *path,
+                                             uint64_t cookie,
+                                             uint64_t cookieverf,
+                                             uint32_t max_entries,
+                                             nfs_cb cb, void *private_data);
 int nfs3_pread_async_internal(struct nfs_context *nfs, struct nfsfh *nfsfh,
                               void *buf, size_t count, uint64_t offset,
                               nfs_cb cb, void *private_data, int update_pos);
@@ -984,6 +1003,9 @@ int nfs4_open_async(struct nfs_context *nfs, const char *path, int flags,
                     int mode, nfs_cb cb, void *private_data);
 int nfs4_opendir_async(struct nfs_context *nfs, const char *path, nfs_cb cb,
                        void *private_data);
+int nfs4_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                                 uint64_t cookie, uint32_t max_entries,
+                                 nfs_cb cb, void *private_data);
 int nfs4_pread_async_internal(struct nfs_context *nfs, struct nfsfh *nfsfh,
                               void *buf, size_t count, uint64_t offset,
                               nfs_cb cb, void *private_data, int update_pos);
diff --git a/include/nfsc/libnfs.h b/include/nfsc/libnfs.h
index be3c8eb..0359eb3 100755
--- a/include/nfsc/libnfs.h
+++ b/include/nfsc/libnfs.h
@@ -1302,6 +1302,224 @@ EXTERN int nfs_opendir_async(struct nfs_context *nfs, const char *path,
 EXTERN int nfs_opendir(struct nfs_context *nfs, const char *path,
                        struct nfsdir **nfsdir);
 
+/*
+ * Async opendir_at_cookie()
+ *
+ * Open a directory starting from a specific cookie position with an optional
+ * limit on the number of entries to fetch.
+ * This allows parallel directory reading by starting enumeration
+ * from different positions in the directory.
+ *
+ * Parameters:
+ *   cookie      - NFS cookie to start reading from (0 for beginning)
+ *   max_entries - Maximum number of entries to fetch. When max_entries > 0,
+ *                 stop fetching after accumulating approximately this many
+ *                 entries (may return slightly more due to batch fetching).
+ *                 When max_entries == 0, read until EOF (original behavior).
+ *
+ * Function returns
+ *  0 : The command was queued successfully. The callback will be invoked once
+ *      the command completes.
+ * <0 : An error occured when trying to queue the command.
+ *      The callback will not be invoked.
+ *
+ * When struct nfsdir * is returned, this resource is closed/freed by calling nfs_closedir()
+ *
+ * When the callback is invoked, status indicates the result:
+ *      0 : Success.
+ *          data is struct nfsdir *
+ * -errno : An error occured.
+ *          data is the error string.
+ *
+ * Note: The cookieverf is set to zero. Some servers may reject this for
+ * non-zero cookies. In that case, you must read from the beginning to
+ * obtain valid cookie+verifier pairs.
+ */
+EXTERN int nfs_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                                       uint64_t cookie, uint32_t max_entries,
+                                       nfs_cb cb, void *private_data);
+/*
+ * Sync opendir_at_cookie()
+ *
+ * Open a directory starting from a specific cookie position with an optional
+ * limit on the number of entries to fetch.
+ * This allows parallel directory reading by starting enumeration
+ * from different positions in the directory.
+ *
+ * Parameters:
+ *   cookie      - NFS cookie to start reading from (0 for beginning)
+ *   max_entries - Maximum number of entries to fetch. When max_entries > 0,
+ *                 stop fetching after accumulating approximately this many
+ *                 entries (may return slightly more due to batch fetching).
+ *                 When max_entries == 0, read until EOF (original behavior).
+ *
+ * Function returns
+ *      0 : Success
+ * -errno : An error occured.
+ *
+ * Note: The cookieverf is set to zero. Some servers may reject this for
+ * non-zero cookies. In that case, you must read from the beginning to
+ * obtain valid cookie+verifier pairs.
+ */
+EXTERN int nfs_opendir_at_cookie(struct nfs_context *nfs, const char *path,
+                                 uint64_t cookie, uint32_t max_entries,
+                                 struct nfsdir **nfsdir);
+
+/*
+ * Async opendir_names_only()
+ *
+ * Open a directory and enumerate entries WITHOUT fetching attributes.
+ * Uses NFS3 READDIR instead of READDIRPLUS for dramatically faster
+ * enumeration of large directories.
+ *
+ * Returned entries will have:
+ * - name: populated
+ * - inode: populated (fileid)
+ * - cookie: populated
+ * - type: 0 (unknown - no attributes fetched)
+ * - size, mtime, etc.: 0/empty (no attributes fetched)
+ *
+ * Use this when you need to enumerate many files quickly and will
+ * fetch attributes separately (e.g., with parallel GETATTR calls).
+ *
+ * Function returns
+ *  0 : The command was queued successfully. The callback will be invoked once
+ *      the command completes.
+ * <0 : An error occured when trying to queue the command.
+ *      The callback will not be invoked.
+ *
+ * When struct nfsdir * is returned, this resource is closed/freed by calling
+ * nfs_closedir()
+ *
+ * When the callback is invoked, status indicates the result:
+ *      0 : Success.
+ *          data is struct nfsdir *
+ * -errno : An error occured.
+ *          data is the error string.
+ */
+EXTERN int nfs_opendir_names_only_async(struct nfs_context *nfs,
+                                         const char *path,
+                                         nfs_cb cb, void *private_data);
+/*
+ * Sync opendir_names_only()
+ *
+ * Open a directory and enumerate entries WITHOUT fetching attributes.
+ * Uses NFS3 READDIR instead of READDIRPLUS for dramatically faster
+ * enumeration of large directories.
+ *
+ * Returned entries will have:
+ * - name: populated
+ * - inode: populated (fileid)
+ * - cookie: populated
+ * - type: 0 (unknown - no attributes fetched)
+ * - size, mtime, etc.: 0/empty (no attributes fetched)
+ *
+ * Use this when you need to enumerate many files quickly and will
+ * fetch attributes separately (e.g., with parallel GETATTR calls).
+ *
+ * Function returns
+ *      0 : Success
+ * -errno : An error occured.
+ */
+EXTERN int nfs_opendir_names_only(struct nfs_context *nfs, const char *path,
+                                   struct nfsdir **nfsdir);
+
+/*
+ * Async opendir_names_only_at_cookie()
+ *
+ * Open a directory using READDIR (names only) starting at a cookie position
+ * with a maximum entry limit.
+ *
+ * This combines the speed of READDIR (no server-side stat) with streaming
+ * capability (cookie positioning + entry limit) for optimal large directory
+ * enumeration.
+ *
+ * Returned entries will have:
+ * - name: populated
+ * - inode: populated (fileid)
+ * - cookie: populated (for getting next batch)
+ * - type: 0 (unknown - no attributes fetched)
+ * - size, mtime, etc.: 0/empty (no attributes fetched)
+ *
+ * The nfsdir structure will have its cookieverf field populated with the
+ * verifier from the server. Pass this back in subsequent calls to continue
+ * the listing correctly.
+ *
+ * Parameters:
+ *   cookie      - NFS cookie to start reading from (0 for beginning,
+ *                 or last entry's cookie from previous batch)
+ *   cookieverf  - Cookie verifier from previous batch (0 for first call,
+ *                 or nfsdir->cookieverf from previous batch)
+ *   max_entries - Maximum entries to fetch (0 = unlimited, but DON'T use 0!)
+ *
+ * Function returns
+ *  0 : The command was queued successfully. The callback will be invoked once
+ *      the command completes.
+ * <0 : An error occured when trying to queue the command.
+ *      The callback will not be invoked.
+ *
+ * When struct nfsdir * is returned, this resource is closed/freed by calling
+ * nfs_closedir()
+ *
+ * When the callback is invoked, status indicates the result:
+ *      0 : Success.
+ *          data is struct nfsdir *
+ * -errno : An error occured.
+ *          data is the error string.
+ *
+ * Usage pattern for streaming:
+ *   uint64_t cookie = 0;
+ *   uint64_t verifier = 0;
+ *   while (1) {
+ *       nfs_opendir_names_only_at_cookie(nfs, path, cookie, verifier,
+ *                                        10000, &dir);
+ *       // Process entries...
+ *       struct nfsdirent *entry;
+ *       while ((entry = nfs_readdir(nfs, dir))) {
+ *           cookie = entry->cookie;  // Save last cookie
+ *       }
+ *       verifier = nfs_readdir_get_cookieverf(dir);  // Save verifier
+ *       int count = ...; // count entries processed
+ *       nfs_closedir(nfs, dir);
+ *       if (count < 10000) break;  // Hit EOF
+ *   }
+ */
+EXTERN int nfs_opendir_names_only_at_cookie_async(struct nfs_context *nfs,
+                                                   const char *path,
+                                                   uint64_t cookie,
+                                                   uint64_t cookieverf,
+                                                   uint32_t max_entries,
+                                                   nfs_cb cb,
+                                                   void *private_data);
+/*
+ * Sync opendir_names_only_at_cookie()
+ *
+ * Open a directory using READDIR (names only) starting at a cookie position
+ * with a maximum entry limit.
+ *
+ * See nfs_opendir_names_only_at_cookie_async() for full documentation.
+ *
+ * Function returns
+ *      0 : Success
+ * -errno : An error occured.
+ */
+EXTERN int nfs_opendir_names_only_at_cookie(struct nfs_context *nfs,
+                                             const char *path,
+                                             uint64_t cookie,
+                                             uint64_t cookieverf,
+                                             uint32_t max_entries,
+                                             struct nfsdir **nfsdir);
+
+/*
+ * nfs_readdir_get_cookieverf()
+ *
+ * Get the cookie verifier from an nfsdir structure.
+ * This is needed when using nfs_opendir_names_only_at_cookie() to properly
+ * resume directory enumeration across batches.
+ *
+ * This function will never block so there is no need for an async version.
+ */
+EXTERN uint64_t nfs_readdir_get_cookieverf(struct nfsdir *nfsdir);
 
 
 /*
diff --git a/lib/libnfs-sync.c b/lib/libnfs-sync.c
index d25566d..bf70267 100644
--- a/lib/libnfs-sync.c
+++ b/lib/libnfs-sync.c
@@ -1364,6 +1364,83 @@ nfs_opendir(struct nfs_context *nfs, const char *path, struct nfsdir **nfsdir)
 	return cb_data.status;
 }
 
+int
+nfs_opendir_at_cookie(struct nfs_context *nfs, const char *path,
+                      uint64_t cookie, uint32_t max_entries,
+                      struct nfsdir **nfsdir)
+{
+	struct sync_cb_data cb_data;
+
+	cb_data.return_data = nfsdir;
+        if (nfs_init_cb_data(&nfs, &cb_data)) {
+                return -1;
+        }
+
+	if (nfs_opendir_at_cookie_async(nfs, path, cookie, max_entries,
+                                        opendir_cb, &cb_data) != 0) {
+		nfs_set_error(nfs, "nfs_opendir_at_cookie_async failed. %s",
+                              nfs_get_error(nfs));
+                nfs_destroy_cb_sem(&cb_data);
+		return -1;
+	}
+
+	wait_for_nfs_reply(nfs, &cb_data);
+        nfs_destroy_cb_sem(&cb_data);
+
+	return cb_data.status;
+}
+
+int
+nfs_opendir_names_only(struct nfs_context *nfs, const char *path,
+                       struct nfsdir **nfsdir)
+{
+	struct sync_cb_data cb_data;
+
+	cb_data.return_data = nfsdir;
+        if (nfs_init_cb_data(&nfs, &cb_data)) {
+                return -1;
+        }
+
+	if (nfs_opendir_names_only_async(nfs, path, opendir_cb, &cb_data) != 0) {
+		nfs_set_error(nfs, "nfs_opendir_names_only_async failed. %s",
+                              nfs_get_error(nfs));
+                nfs_destroy_cb_sem(&cb_data);
+		return -1;
+	}
+
+	wait_for_nfs_reply(nfs, &cb_data);
+        nfs_destroy_cb_sem(&cb_data);
+
+	return cb_data.status;
+}
+
+int
+nfs_opendir_names_only_at_cookie(struct nfs_context *nfs, const char *path,
+                                  uint64_t cookie, uint64_t cookieverf,
+                                  uint32_t max_entries, struct nfsdir **nfsdir)
+{
+	struct sync_cb_data cb_data;
+
+	cb_data.return_data = nfsdir;
+        if (nfs_init_cb_data(&nfs, &cb_data)) {
+                return -1;
+        }
+
+	if (nfs_opendir_names_only_at_cookie_async(nfs, path, cookie, cookieverf,
+                                                   max_entries, opendir_cb,
+                                                   &cb_data) != 0) {
+		nfs_set_error(nfs, "nfs_opendir_names_only_at_cookie_async "
+                              "failed. %s", nfs_get_error(nfs));
+                nfs_destroy_cb_sem(&cb_data);
+		return -1;
+	}
+
+	wait_for_nfs_reply(nfs, &cb_data);
+        nfs_destroy_cb_sem(&cb_data);
+
+	return cb_data.status;
+}
+
 
 /*
  * lseek()
diff --git a/lib/libnfs-win32.def b/lib/libnfs-win32.def
index 14bbe90..96ac39d 100644
--- a/lib/libnfs-win32.def
+++ b/lib/libnfs-win32.def
@@ -62,6 +62,8 @@ nfs_open2
 nfs_open2_async
 nfs_opendir
 nfs_opendir_async
+nfs_opendir_at_cookie
+nfs_opendir_at_cookie_async
 nfs_parse_url_full
 nfs_parse_url_dir
 nfs_parse_url_incomplete
diff --git a/lib/libnfs.c b/lib/libnfs.c
index bbe6666..24f5b2a 100755
--- a/lib/libnfs.c
+++ b/lib/libnfs.c
@@ -1980,6 +1980,80 @@ nfs_opendir_async(struct nfs_context *nfs, const char *path, nfs_cb cb,
         }
 }
 
+int
+nfs_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                            uint64_t cookie, uint32_t max_entries,
+                            nfs_cb cb, void *private_data)
+{
+	switch (nfs->nfsi->version) {
+        case NFS_V3:
+                return nfs3_opendir_at_cookie_async(nfs, path, cookie,
+                                                    max_entries, cb,
+                                                    private_data);
+        case NFS_V4:
+                return nfs4_opendir_at_cookie_async(nfs, path, cookie,
+                                                    max_entries, cb,
+                                                    private_data);
+        default:
+                nfs_set_error(nfs, "%s does not support NFSv%d",
+                              __FUNCTION__, nfs->nfsi->version);
+                return -1;
+        }
+}
+
+int
+nfs_opendir_names_only_async(struct nfs_context *nfs, const char *path,
+                             nfs_cb cb, void *private_data)
+{
+	switch (nfs->nfsi->version) {
+        case NFS_V3:
+                return nfs3_opendir_names_only_async(nfs, path, cb,
+                                                     private_data);
+        case NFS_V4:
+                /* NFSv4 READDIR can request specific attributes via bitmap,
+                 * but that's more complex. Fall back to regular opendir. */
+                return nfs4_opendir_async(nfs, path, cb, private_data);
+        default:
+                nfs_set_error(nfs, "%s does not support NFSv%d",
+                              __FUNCTION__, nfs->nfsi->version);
+                return -1;
+        }
+}
+
+int
+nfs_opendir_names_only_at_cookie_async(struct nfs_context *nfs,
+                                        const char *path,
+                                        uint64_t cookie,
+                                        uint64_t cookieverf,
+                                        uint32_t max_entries,
+                                        nfs_cb cb, void *private_data)
+{
+	switch (nfs->nfsi->version) {
+        case NFS_V3:
+                return nfs3_opendir_names_only_at_cookie_async(nfs, path, cookie,
+                                                                cookieverf,
+                                                                max_entries, cb,
+                                                                private_data);
+        case NFS_V4:
+                /* NFSv4 fallback: use regular opendir_at_cookie (still does stat).
+                 * Full NFSv4 optimization would require custom attribute bitmap.
+                 * Note: NFSv4 doesn't use cookieverf the same way, ignore it. */
+                return nfs4_opendir_at_cookie_async(nfs, path, cookie,
+                                                     max_entries, cb,
+                                                     private_data);
+        default:
+                nfs_set_error(nfs, "%s does not support NFSv%d",
+                              __FUNCTION__, nfs->nfsi->version);
+                return -1;
+        }
+}
+
+uint64_t
+nfs_readdir_get_cookieverf(struct nfsdir *nfsdir)
+{
+	return nfsdir->cookieverf;
+}
+
 struct nfsdirent *
 nfs_readdir(struct nfs_context *nfs _U_, struct nfsdir *nfsdir)
 {
diff --git a/lib/nfs_v3.c b/lib/nfs_v3.c
index 17d2ac2..f231b65 100644
--- a/lib/nfs_v3.c
+++ b/lib/nfs_v3.c
@@ -2758,6 +2758,19 @@ lookup_missing_attributes(struct nfs_context *nfs,
 	return 0;
 }
 
+/* Helper function to count entries in nfsdir */
+static uint32_t
+nfsdir_count_entries(struct nfsdir *nfsdir)
+{
+	uint32_t count = 0;
+	struct nfsdirent *entry = nfsdir->entries;
+	while (entry != NULL) {
+		count++;
+		entry = entry->next;
+	}
+	return count;
+}
+
 static void
 nfs3_opendir_2_cb(struct rpc_context *rpc, int status, void *command_data,
                   void *private_data)
@@ -3021,6 +3034,24 @@ nfs3_opendir_cb(struct rpc_context *rpc, int status, void *command_data,
 		entry  = entry->nextentry;
 	}
 
+	/* Check if we've reached the max_entries limit */
+	if (data->max_entries > 0 &&
+	    nfsdir_count_entries(nfsdir) >= data->max_entries) {
+		/* We've reached the limit, return what we have */
+		if (res->READDIRPLUS3res_u.resok.dir_attributes.attributes_follow) {
+			fattr3_to_nfs_attr(&nfsdir->attr, &res->READDIRPLUS3res_u.resok.dir_attributes.post_op_attr_u.attributes);
+		}
+		nfsdir->current = nfsdir->entries;
+
+		if (lookup_missing_attributes(nfs, nfsdir, data) == 0) {
+			data->cb(0, nfs, nfsdir, data->private_data);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		return;
+	}
+
 	if (res->READDIRPLUS3res_u.resok.reply.eof == 0) {
 		READDIRPLUS3args args;
 
@@ -3136,6 +3167,535 @@ nfs3_opendir_async(struct nfs_context *nfs, const char *path, nfs_cb cb,
 	return 0;
 }
 
+/*
+ * Names-only directory reading using plain READDIR (not READDIRPLUS).
+ * This is dramatically faster for large directories because the server
+ * doesn't need to stat() each file - it just reads the directory B-tree.
+ */
+static void
+nfs3_opendir_names_only_cb(struct rpc_context *rpc, int status,
+                           void *command_data, void *private_data)
+{
+	READDIR3res *res = command_data;
+	struct nfs_cb_data *data = private_data;
+	struct nfs_context *nfs = data->nfs;
+	struct nfsdir *nfsdir = data->continue_data;
+	struct nfsdirent *nfsdirent;
+	struct entry3 *entry;
+	uint64_t cookie = 0;
+
+	assert(rpc->magic == RPC_CONTEXT_MAGIC);
+
+	if (check_nfs3_error(nfs, status, data, command_data)) {
+		nfs_free_nfsdir(nfsdir);
+		data->continue_data = NULL;
+		free_nfs_cb_data(data);
+		return;
+	}
+
+	if (res->status != NFS3_OK) {
+		nfs_set_error(nfs, "NFS: READDIR of %s failed with "
+                              "%s(%d)", data->saved_path,
+                              nfsstat3_to_str(res->status),
+                              nfsstat3_to_errno(res->status));
+		data->cb(nfsstat3_to_errno(res->status), nfs,
+                         nfs_get_error(nfs), data->private_data);
+		nfs_free_nfsdir(nfsdir);
+		data->continue_data = NULL;
+		free_nfs_cb_data(data);
+		return;
+	}
+
+	entry = res->READDIR3res_u.resok.reply.entries;
+	while (entry != NULL) {
+		nfsdirent = calloc(1, sizeof(struct nfsdirent));
+		if (nfsdirent == NULL) {
+			data->cb(-ENOMEM, nfs, "Failed to allocate dirent",
+                                 data->private_data);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		nfsdirent->name = strdup(entry->name);
+		if (nfsdirent->name == NULL) {
+			data->cb(-ENOMEM, nfs, "Failed to allocate "
+                                 "dirent->name", data->private_data);
+			free(nfsdirent);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		nfsdirent->inode = entry->fileid;
+		nfsdirent->cookie = entry->cookie;
+		/* type stays 0 (unknown) - no attributes fetched */
+
+		nfsdirent->next = nfsdir->entries;
+		nfsdir->entries = nfsdirent;
+
+		cookie = entry->cookie;
+		entry = entry->nextentry;
+	}
+
+	if (res->READDIR3res_u.resok.reply.eof == 0) {
+		READDIR3args args;
+
+		args.dir.data.data_len = data->fh.len;
+		args.dir.data.data_val = data->fh.val;
+		args.cookie = cookie;
+		memcpy(&args.cookieverf, res->READDIR3res_u.resok.cookieverf,
+                       sizeof(cookieverf3));
+		args.count = nfs->nfsi->readdir_dircount;
+
+		if (rpc_nfs3_readdir_task(nfs->rpc, nfs3_opendir_names_only_cb,
+                                          &args, data) == NULL) {
+			nfs_set_error(nfs, "RPC error: Failed to send "
+                                      "READDIR call for %s", data->path);
+			data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                                 data->private_data);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		return;
+	}
+
+	/* Store directory attributes if provided */
+	if (res->READDIR3res_u.resok.dir_attributes.attributes_follow)
+		fattr3_to_nfs_attr(&nfsdir->attr, &res->READDIR3res_u.resok.dir_attributes.post_op_attr_u.attributes);
+
+	nfsdir->current = nfsdir->entries;
+
+	/*
+	 * KEY DIFFERENCE from nfs3_opendir_2_cb:
+	 * Do NOT call lookup_missing_attributes()!
+	 * Return immediately with names only - this is the whole point.
+	 */
+	data->cb(0, nfs, nfsdir, data->private_data);
+	data->continue_data = NULL;
+	free_nfs_cb_data(data);
+}
+
+static int
+nfs3_opendir_names_only_continue_internal(struct nfs_context *nfs,
+                                          struct nfs_attr *attr _U_,
+                                          struct nfs_cb_data *data)
+{
+	READDIR3args args;
+	struct nfsdir *nfsdir = data->continue_data;
+
+	/* Skip cache lookup - names-only mode is meant for fresh scans */
+
+	nfsdir->fh.len = data->fh.len;
+	nfsdir->fh.val = malloc(nfsdir->fh.len);
+	if (nfsdir->fh.val == NULL) {
+		nfs_set_error(nfs, "OOM when allocating fh for nfsdir");
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	memcpy(nfsdir->fh.val, data->fh.val, data->fh.len);
+
+	args.dir.data.data_len = data->fh.len;
+	args.dir.data.data_val = data->fh.val;
+	args.cookie = 0;
+	memset(&args.cookieverf, 0, sizeof(cookieverf3));
+	args.count = nfs->nfsi->readdir_dircount;
+
+	/* Use READDIR, not READDIRPLUS - the key optimization */
+	if (rpc_nfs3_readdir_task(nfs->rpc, nfs3_opendir_names_only_cb,
+                                  &args, data) == NULL) {
+		nfs_set_error(nfs, "RPC error: Failed to send "
+                              "READDIR call for %s", data->path);
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	return 0;
+}
+
+int
+nfs3_opendir_names_only_async(struct nfs_context *nfs, const char *path,
+                              nfs_cb cb, void *private_data)
+{
+	struct nfsdir *nfsdir;
+
+	nfsdir = calloc(1, sizeof(struct nfsdir));
+	if (nfsdir == NULL) {
+		nfs_set_error(nfs, "failed to allocate buffer for nfsdir");
+		return -1;
+	}
+
+	if (nfs3_lookuppath_async(nfs, path, 0, cb, private_data,
+                                  nfs3_opendir_names_only_continue_internal,
+                                  nfsdir, free, 0) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Structure to hold opendir_at_cookie parameters */
+struct opendir_at_cookie_data {
+	struct nfsdir *nfsdir;
+	uint32_t max_entries;
+};
+
+static void
+free_opendir_at_cookie_data(void *ptr)
+{
+	struct opendir_at_cookie_data *odata = ptr;
+	if (odata) {
+		/* nfsdir may still be in odata if an error occurred before transfer */
+		if (odata->nfsdir) {
+			nfs_free_nfsdir(odata->nfsdir);
+		}
+		free(odata);
+	}
+}
+
+static int
+nfs3_opendir_at_cookie_continue_internal(struct nfs_context *nfs,
+                                         struct nfs_attr *attr _U_,
+                                         struct nfs_cb_data *data)
+{
+	READDIRPLUS3args args;
+	struct opendir_at_cookie_data *odata = data->continue_data;
+	struct nfsdir *nfsdir = odata->nfsdir;
+
+	/* Note: We skip the dircache check when starting at a non-zero cookie
+	 * because the cache contains the full directory listing from cookie 0.
+	 */
+
+	/* Transfer max_entries to data for use in nfs3_opendir_cb */
+	data->max_entries = odata->max_entries;
+
+	/* Transfer nfsdir ownership to data->continue_data for nfs3_opendir_cb */
+	data->continue_data = nfsdir;
+	data->free_continue_data = (void (*)(void *))nfs_free_nfsdir;
+	odata->nfsdir = NULL;  /* Mark as transferred before freeing wrapper */
+	free(odata);  /* Free the wrapper, nfsdir is now owned by data */
+
+	nfsdir->fh.len  = data->fh.len;
+	nfsdir->fh.val = malloc(nfsdir->fh.len);
+	if (nfsdir->fh.val == NULL) {
+		nfs_set_error(nfs, "OOM when allocating fh for nfsdir");
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	memcpy(nfsdir->fh.val, data->fh.val, data->fh.len);
+
+	args.dir.data.data_len = data->fh.len;
+	args.dir.data.data_val = data->fh.val;
+	args.cookie = data->continue_int;  /* Use the starting cookie */
+	memset(&args.cookieverf, 0, sizeof(cookieverf3));
+	args.dircount = nfs->nfsi->readdir_dircount;
+	args.maxcount = nfs->nfsi->readdir_maxcount;
+	if (rpc_nfs3_readdirplus_task(nfs->rpc, nfs3_opendir_cb,
+                                      &args, data) == NULL) {
+		nfs_set_error(nfs, "RPC error: Failed to send "
+                              "READDIRPLUS call for %s", data->path);
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	return 0;
+}
+
+int
+nfs3_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                             uint64_t cookie, uint32_t max_entries,
+                             nfs_cb cb, void *private_data)
+{
+	struct opendir_at_cookie_data *odata;
+	struct nfsdir *nfsdir;
+
+	odata = calloc(1, sizeof(struct opendir_at_cookie_data));
+	if (odata == NULL) {
+		nfs_set_error(nfs, "failed to allocate buffer for opendir data");
+		return -1;
+	}
+
+	nfsdir = calloc(1, sizeof(struct nfsdir));
+	if (nfsdir == NULL) {
+		free(odata);
+		nfs_set_error(nfs, "failed to allocate buffer for nfsdir");
+		return -1;
+	}
+
+	odata->nfsdir = nfsdir;
+	odata->max_entries = max_entries;
+
+	if (nfs3_lookuppath_async(nfs, path, 0, cb, private_data,
+                                  nfs3_opendir_at_cookie_continue_internal,
+                                  odata, free_opendir_at_cookie_data,
+                                  cookie) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Names-only directory reading at a specific cookie position using plain
+ * READDIR (not READDIRPLUS). This combines the speed of READDIR with
+ * streaming capability (cookie positioning + entry limit) for optimal
+ * large directory enumeration.
+ */
+
+/* Structure to hold opendir_names_only_at_cookie parameters */
+struct opendir_names_only_at_cookie_data {
+	struct nfsdir *nfsdir;
+	uint32_t max_entries;
+	uint64_t cookieverf;  /* Input verifier from previous batch */
+};
+
+static void
+free_opendir_names_only_at_cookie_data(void *ptr)
+{
+	struct opendir_names_only_at_cookie_data *odata = ptr;
+	if (odata) {
+		/* nfsdir may still be in odata if an error occurred before transfer */
+		if (odata->nfsdir) {
+			nfs_free_nfsdir(odata->nfsdir);
+		}
+		free(odata);
+	}
+}
+
+static void
+nfs3_opendir_names_only_at_cookie_cb(struct rpc_context *rpc, int status,
+                                      void *command_data, void *private_data)
+{
+	READDIR3res *res = command_data;  /* READDIR, not READDIRPLUS! */
+	struct nfs_cb_data *data = private_data;
+	struct nfs_context *nfs = data->nfs;
+	struct nfsdir *nfsdir = data->continue_data;
+	struct nfsdirent *nfsdirent;
+	struct entry3 *entry;
+	uint64_t cookie = 0;
+
+	assert(rpc->magic == RPC_CONTEXT_MAGIC);
+
+	if (check_nfs3_error(nfs, status, data, command_data)) {
+		nfs_free_nfsdir(nfsdir);
+		data->continue_data = NULL;
+		free_nfs_cb_data(data);
+		return;
+	}
+
+	if (res->status != NFS3_OK) {
+		nfs_set_error(nfs, "NFS: READDIR of %s failed with "
+                              "%s(%d)", data->saved_path,
+                              nfsstat3_to_str(res->status),
+                              nfsstat3_to_errno(res->status));
+		data->cb(nfsstat3_to_errno(res->status), nfs,
+                         nfs_get_error(nfs), data->private_data);
+		nfs_free_nfsdir(nfsdir);
+		data->continue_data = NULL;
+		free_nfs_cb_data(data);
+		return;
+	}
+
+	/* Parse entries (READDIR format - simpler than READDIRPLUS) */
+	entry = res->READDIR3res_u.resok.reply.entries;
+	while (entry != NULL) {
+		nfsdirent = calloc(1, sizeof(struct nfsdirent));
+		if (nfsdirent == NULL) {
+			data->cb(-ENOMEM, nfs, "Failed to allocate dirent",
+                                 data->private_data);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		nfsdirent->name = strdup(entry->name);
+		if (nfsdirent->name == NULL) {
+			data->cb(-ENOMEM, nfs, "Failed to allocate "
+                                 "dirent->name", data->private_data);
+			free(nfsdirent);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		nfsdirent->inode = entry->fileid;
+		nfsdirent->cookie = entry->cookie;
+		/* type stays 0 (unknown) - no attributes fetched */
+
+		nfsdirent->next = nfsdir->entries;
+		nfsdir->entries = nfsdirent;
+
+		cookie = entry->cookie;
+		entry = entry->nextentry;
+	}
+
+	/* Check if we've reached the max_entries limit */
+	if (data->max_entries > 0 &&
+	    nfsdir_count_entries(nfsdir) >= data->max_entries) {
+		/* We've reached the limit, return what we have */
+		if (res->READDIR3res_u.resok.dir_attributes.attributes_follow) {
+			fattr3_to_nfs_attr(&nfsdir->attr,
+			    &res->READDIR3res_u.resok.dir_attributes.post_op_attr_u.attributes);
+		}
+
+		/* Store cookieverf for next batch */
+		memcpy(&nfsdir->cookieverf, res->READDIR3res_u.resok.cookieverf,
+		       sizeof(cookieverf3));
+
+		nfsdir->current = nfsdir->entries;
+		/* NO lookup_missing_attributes()! Just return names. */
+		data->cb(0, nfs, nfsdir, data->private_data);
+		data->continue_data = NULL;
+		free_nfs_cb_data(data);
+		return;
+	}
+
+	/* Not at limit yet, check for more data */
+	if (res->READDIR3res_u.resok.reply.eof == 0) {
+		READDIR3args args;  /* READDIR, not READDIRPLUS! */
+
+		args.dir.data.data_len = data->fh.len;
+		args.dir.data.data_val = data->fh.val;
+		args.cookie = cookie;
+		memcpy(&args.cookieverf, res->READDIR3res_u.resok.cookieverf,
+		       sizeof(cookieverf3));
+		args.count = nfs->nfsi->readdir_dircount;
+
+		if (rpc_nfs3_readdir_task(nfs->rpc,
+		                           nfs3_opendir_names_only_at_cookie_cb,
+		                           &args, data) == NULL) {
+			nfs_set_error(nfs, "RPC error: Failed to send "
+                                      "READDIR call for %s", data->path);
+			data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                                 data->private_data);
+			nfs_free_nfsdir(nfsdir);
+			data->continue_data = NULL;
+			free_nfs_cb_data(data);
+			return;
+		}
+		return;
+	}
+
+	/* EOF reached */
+	if (res->READDIR3res_u.resok.dir_attributes.attributes_follow) {
+		fattr3_to_nfs_attr(&nfsdir->attr,
+		    &res->READDIR3res_u.resok.dir_attributes.post_op_attr_u.attributes);
+	}
+
+	/* Store the cookieverf for the caller to use in next batch */
+	memcpy(&nfsdir->cookieverf, res->READDIR3res_u.resok.cookieverf,
+	       sizeof(cookieverf3));
+
+	nfsdir->current = nfsdir->entries;
+
+	/* NO lookup_missing_attributes()! Just return names. */
+	data->cb(0, nfs, nfsdir, data->private_data);
+	data->continue_data = NULL;
+	free_nfs_cb_data(data);
+}
+
+static int
+nfs3_opendir_names_only_at_cookie_continue_internal(struct nfs_context *nfs,
+                                                     struct nfs_attr *attr _U_,
+                                                     struct nfs_cb_data *data)
+{
+	READDIR3args args;  /* READDIR, not READDIRPLUS! */
+	struct opendir_names_only_at_cookie_data *odata = data->continue_data;
+	struct nfsdir *nfsdir = odata->nfsdir;
+	uint64_t input_verifier = odata->cookieverf;
+
+	/* Transfer max_entries to data for use in callback */
+	data->max_entries = odata->max_entries;
+
+	/* Transfer nfsdir ownership to data->continue_data */
+	data->continue_data = nfsdir;
+	data->free_continue_data = (void (*)(void *))nfs_free_nfsdir;
+	odata->nfsdir = NULL;  /* Mark as transferred before freeing wrapper */
+	free(odata);  /* Free the wrapper, nfsdir is now owned by data */
+
+	nfsdir->fh.len = data->fh.len;
+	nfsdir->fh.val = malloc(nfsdir->fh.len);
+	if (nfsdir->fh.val == NULL) {
+		nfs_set_error(nfs, "OOM when allocating fh for nfsdir");
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	memcpy(nfsdir->fh.val, data->fh.val, data->fh.len);
+
+	args.dir.data.data_len = data->fh.len;
+	args.dir.data.data_val = data->fh.val;
+	args.cookie = data->continue_int;  /* Starting cookie */
+
+	/* Use the input cookieverf for resumption.
+	 * For first call (cookie=0), verifier should be 0.
+	 * For subsequent calls, use verifier from previous response. */
+	memcpy(&args.cookieverf, &input_verifier, sizeof(cookieverf3));
+
+	args.count = nfs->nfsi->readdir_dircount;
+
+	/* Use READDIR (Proc 16), not READDIRPLUS (Proc 17) */
+	if (rpc_nfs3_readdir_task(nfs->rpc,
+	                           nfs3_opendir_names_only_at_cookie_cb,
+	                           &args, data) == NULL) {
+		nfs_set_error(nfs, "RPC error: Failed to send "
+                              "READDIR call for %s", data->path);
+		data->cb(-ENOMEM, nfs, nfs_get_error(nfs),
+                         data->private_data);
+		free_nfs_cb_data(data);
+		return -1;
+	}
+	return 0;
+}
+
+int
+nfs3_opendir_names_only_at_cookie_async(struct nfs_context *nfs,
+                                         const char *path,
+                                         uint64_t cookie,
+                                         uint64_t cookieverf,
+                                         uint32_t max_entries,
+                                         nfs_cb cb, void *private_data)
+{
+	struct opendir_names_only_at_cookie_data *odata;
+	struct nfsdir *nfsdir;
+
+	odata = calloc(1, sizeof(struct opendir_names_only_at_cookie_data));
+	if (odata == NULL) {
+		nfs_set_error(nfs, "failed to allocate buffer for opendir data");
+		return -1;
+	}
+
+	nfsdir = calloc(1, sizeof(struct nfsdir));
+	if (nfsdir == NULL) {
+		free(odata);
+		nfs_set_error(nfs, "failed to allocate buffer for nfsdir");
+		return -1;
+	}
+
+	odata->nfsdir = nfsdir;
+	odata->max_entries = max_entries;
+	odata->cookieverf = cookieverf;  /* Store input verifier */
+
+	/* The cookie goes as the last argument - ends up in data->continue_int */
+	if (nfs3_lookuppath_async(nfs, path, 0, cb, private_data,
+	                          nfs3_opendir_names_only_at_cookie_continue_internal,
+	                          odata, free_opendir_names_only_at_cookie_data,
+	                          cookie) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
 struct mknod_cb_data {
        char *path;
        int mode;
diff --git a/lib/nfs_v4.c b/lib/nfs_v4.c
index 79aee88..fdc7b0f 100644
--- a/lib/nfs_v4.c
+++ b/lib/nfs_v4.c
@@ -3742,6 +3742,19 @@ nfs4_opendir_2_cb(struct rpc_context *rpc, int status, void *command_data,
         nfs4_parse_readdir(nfs, data, rdresok);
 }
 
+/* Helper function to count entries in nfsdir */
+static uint32_t
+nfs4_nfsdir_count_entries(struct nfsdir *nfsdir)
+{
+	uint32_t count = 0;
+	struct nfsdirent *entry = nfsdir->entries;
+	while (entry != NULL) {
+		count++;
+		entry = entry->next;
+	}
+	return count;
+}
+
 static void
 nfs4_opendir_continue(struct nfs_context *nfs, struct nfs4_cb_data *data)
 {
@@ -3868,6 +3881,21 @@ nfs4_parse_readdir(struct nfs_context *nfs, struct nfs4_cb_data *data,
                 e = e->nextentry;
         }
 
+        /* Check if we've reached the max_entries limit */
+        if (data->filler.blob3.val != NULL) {
+                uint32_t max_entries;
+                memcpy(&max_entries, data->filler.blob3.val, sizeof(uint32_t));
+                if (max_entries > 0 &&
+                    nfs4_nfsdir_count_entries(nfsdir) >= max_entries) {
+                        /* We've reached the limit, return what we have */
+                        nfsdir->current = nfsdir->entries;
+                        data->filler.blob1.val = NULL;
+                        data->cb(0, nfs, nfsdir, data->private_data);
+                        free_nfs4_cb_data(data);
+                        return;
+                }
+        }
+
         if (res->reply.eof == 0) {
                 nfs4_opendir_continue(nfs, data);
                 return;
@@ -3996,6 +4024,69 @@ nfs4_opendir_async(struct nfs_context *nfs, const char *path, nfs_cb cb,
         return 0;
 }
 
+/* blob0 is the directory filehandle
+ * blob1 is nfsdir
+ * blob2 is the cookie
+ * blob3 is max_entries (optional, for opendir_at_cookie)
+ */
+int
+nfs4_opendir_at_cookie_async(struct nfs_context *nfs, const char *path,
+                             uint64_t cookie, uint32_t max_entries,
+                             nfs_cb cb, void *private_data)
+{
+        struct nfs4_cb_data *data;
+	struct nfsdir *nfsdir;
+
+        data = init_cb_data_full_path(nfs, path);
+        if (data == NULL) {
+                return -1;
+        }
+
+        data->cb           = cb;
+        data->private_data = private_data;
+        data->filler.func = nfs4_populate_readdir;
+        data->filler.max_op = 2;
+
+	nfsdir = calloc(1, sizeof(struct nfsdir));
+	if (nfsdir == NULL) {
+                free_nfs4_cb_data(data);
+		nfs_set_error(nfs, "failed to allocate buffer for nfsdir");
+		return -1;
+	}
+
+        data->filler.blob1.val = nfsdir;
+        data->filler.blob1.free = (blob_free)nfs_free_nfsdir;
+
+	data->filler.blob2.val = calloc(1, sizeof(uint64_t));
+	if (data->filler.blob2.val == NULL) {
+                free_nfs4_cb_data(data);
+		nfs_set_error(nfs, "failed to allocate buffer for cookie");
+		return -1;
+	}
+        data->filler.blob2.free = (blob_free)free;
+        /* Set the starting cookie */
+        memcpy(data->filler.blob2.val, &cookie, sizeof(uint64_t));
+
+        /* Store max_entries in blob3 if specified */
+        if (max_entries > 0) {
+                data->filler.blob3.val = calloc(1, sizeof(uint32_t));
+                if (data->filler.blob3.val == NULL) {
+                        free_nfs4_cb_data(data);
+                        nfs_set_error(nfs, "failed to allocate buffer for max_entries");
+                        return -1;
+                }
+                data->filler.blob3.free = (blob_free)free;
+                memcpy(data->filler.blob3.val, &max_entries, sizeof(uint32_t));
+        }
+
+        if (nfs4_lookup_path_async(nfs, data, nfs4_opendir_cb) < 0) {
+                free_nfs4_cb_data(data);
+                return -1;
+        }
+
+        return 0;
+}
+
 static void
 nfs4_truncate_close_cb(struct rpc_context *rpc, int status, void *command_data,
                       void *private_data)
